<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="2"><p><A href=http://www.atmel.com ><img src="atmel.jpg"/ border=0></A></p><br /></td>
    <td colspan="2"> <strong><font face="Helvetica" color="#000000" size="+3">Xmega Application Note</font></strong></td>
    <td colspan="2"><p><A href=http://www.atmel.com/products/AVR><img src="AVR_logo_blue.gif"/ border=0></A></p><br /></td>
  </tr>
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>
</table>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>NVM driver EEPROM handling<br/>
<small>
[<a class="el" href="group__nvm__group.html">NVM driver</a>]</small>
</h1>
<p>Functions for handling internal EEPROM memory.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for NVM driver EEPROM handling:</div>
<div class="dynsection">
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga6f939f98287b320d39418ed72ba8cfe1">nvm_eeprom_atomic_write_page</a> (uint8_t page_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase and write bytes from page buffer into EEPROM.  <a href="#ga6f939f98287b320d39418ed72ba8cfe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gac87e872a5b79f534b409735066514274">nvm_eeprom_erase_all</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase entire EEPROM memory.  <a href="#gac87e872a5b79f534b409735066514274"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga0d4308eb16bb32a0a522744a28f5969e">nvm_eeprom_erase_bytes_in_all_pages</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase bytes from all EEPROM pages.  <a href="#ga0d4308eb16bb32a0a522744a28f5969e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gaf2f736b02cc1a2d7e27f45d0d5cc9bcb">nvm_eeprom_erase_bytes_in_page</a> (uint8_t page_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase bytes from EEPROM page.  <a href="#gaf2f736b02cc1a2d7e27f45d0d5cc9bcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga75f4e0c9419252c81387e79356433bca">nvm_eeprom_erase_page</a> (uint8_t page_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase EEPROM page.  <a href="#ga75f4e0c9419252c81387e79356433bca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga6228a0fc4ddfe85c4b6c7b032f81e0df">nvm_eeprom_fill_buffer_with_value</a> (uint8_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill temporary EEPROM page buffer with value.  <a href="#ga6228a0fc4ddfe85c4b6c7b032f81e0df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga309765606eafd344378f1ddd20fc4129">nvm_eeprom_flush_buffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush temporary EEPROM page buffer.  <a href="#ga309765606eafd344378f1ddd20fc4129"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga47aaaec22fa50f0cfb90657357885fa9">nvm_eeprom_load_byte_to_buffer</a> (uint8_t byte_addr, uint8_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load single byte into temporary page buffer.  <a href="#ga47aaaec22fa50f0cfb90657357885fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga02f10adbf959b8525bbaf777ad6e43b6">nvm_eeprom_load_page_to_buffer</a> (const uint8_t *values)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load entire page into temporary EEPROM page buffer.  <a href="#ga02f10adbf959b8525bbaf777ad6e43b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga7bb4f6cdba9a963add9bf84ee085eb0d">nvm_eeprom_read_byte</a> (uint8_t page_addr, uint8_t byte_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read one byte from EEPROM using IO mapping.  <a href="#ga7bb4f6cdba9a963add9bf84ee085eb0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gae8b5ca90e2d370109bed6e6adc8d9307">nvm_eeprom_split_write_page</a> (uint8_t page_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write (without erasing) EEPROM page.  <a href="#gae8b5ca90e2d370109bed6e6adc8d9307"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gafc559e7bbb0598a1e4c8b3f4344bdc51">nvm_eeprom_write_byte</a> (uint8_t page_addr, uint8_t byte_addr, uint8_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write one byte to EEPROM using IO mapping.  <a href="#gafc559e7bbb0598a1e4c8b3f4344bdc51"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions for handling internal EEPROM memory. </p>
<p>The internal EEPROM can be used to store data that will persist after power is removed. This can typically be used to store calibration data, application state, encryption keys or other data that need to be preserved when power is removed.</p>
<p>The functions in this module uses IO register access to manipulate the EEPROM.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The functions in this module are modifying the NVM.CMD register. If the application are using program space access in interrupts (__flash pointers in IAR EW or pgm_read_byte in GCC) interrupts needs to be disabled when running EEPROM access functions. If not the program space reads will be corrupted. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6f939f98287b320d39418ed72ba8cfe1"></a><!-- doxytag: member="nvm.c::nvm_eeprom_atomic_write_page" ref="ga6f939f98287b320d39418ed72ba8cfe1" args="(uint8_t page_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_atomic_write_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>page_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase and write bytes from page buffer into EEPROM. </p>
<p>This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.</p>
<p>As this is an atomic write, the page in EEPROM will be erased automatically before writing. Note that only the page buffer locations that have been loaded will be used when writing to EEPROM. Page buffer locations that have not been loaded will be left untouched in EEPROM.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_addr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac87e872a5b79f534b409735066514274"></a><!-- doxytag: member="nvm.c::nvm_eeprom_erase_all" ref="gac87e872a5b79f534b409735066514274" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_all </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase entire EEPROM memory. </p>
<p>This function erases the entire EEPROM memory block to 0xFF. </p>

</div>
</div>
<a class="anchor" id="ga0d4308eb16bb32a0a522744a28f5969e"></a><!-- doxytag: member="nvm.c::nvm_eeprom_erase_bytes_in_all_pages" ref="ga0d4308eb16bb32a0a522744a28f5969e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_bytes_in_all_pages </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase bytes from all EEPROM pages. </p>
<p>This function erases bytes from all EEPROM pages, so that every location written to in the page buffer reads 0xFF. </p>

</div>
</div>
<a class="anchor" id="gaf2f736b02cc1a2d7e27f45d0d5cc9bcb"></a><!-- doxytag: member="nvm.c::nvm_eeprom_erase_bytes_in_page" ref="gaf2f736b02cc1a2d7e27f45d0d5cc9bcb" args="(uint8_t page_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_bytes_in_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>page_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase bytes from EEPROM page. </p>
<p>This function erases bytes from one EEPROM page, so that every location written to in the page buffer reads 0xFF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_addr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75f4e0c9419252c81387e79356433bca"></a><!-- doxytag: member="nvm.c::nvm_eeprom_erase_page" ref="ga75f4e0c9419252c81387e79356433bca" args="(uint8_t page_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>page_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase EEPROM page. </p>
<p>This function erases one EEPROM page, so that every location reads 0xFF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_addr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6228a0fc4ddfe85c4b6c7b032f81e0df"></a><!-- doxytag: member="nvm.c::nvm_eeprom_fill_buffer_with_value" ref="ga6228a0fc4ddfe85c4b6c7b032f81e0df" args="(uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_fill_buffer_with_value </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill temporary EEPROM page buffer with value. </p>
<p>This fills the the EEPROM page buffers with a given value. If memory mapped EEPROM is enabled, this function will not work.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only the lower part of the address is used to address the buffer. Therefore, no address parameter is needed. In the end, the data is written to the EEPROM page given by the address parameter to the EEPROM write page operation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to copy to the page buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga309765606eafd344378f1ddd20fc4129"></a><!-- doxytag: member="nvm.c::nvm_eeprom_flush_buffer" ref="ga309765606eafd344378f1ddd20fc4129" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_flush_buffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush temporary EEPROM page buffer. </p>
<p>This function flushes the EEPROM page buffers. This function will cancel any ongoing EEPROM page buffer loading operations, if any. This function also works for memory mapped EEPROM access.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>An EEPROM write operations will automatically flush the buffer for you. </dd>
<dd>
The function does not preserve the value of the NVM.CMD register </dd></dl>

</div>
</div>
<a class="anchor" id="ga47aaaec22fa50f0cfb90657357885fa9"></a><!-- doxytag: member="nvm.c::nvm_eeprom_load_byte_to_buffer" ref="ga47aaaec22fa50f0cfb90657357885fa9" args="(uint8_t byte_addr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_load_byte_to_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byte_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load single byte into temporary page buffer. </p>
<p>This function loads one byte into the temporary EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes. Also, if multiple bytes are loaded into the same location, they will be ANDed together, thus 0x55 and 0xAA will result in 0x00 in the buffer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only one page buffer exist, thus only one page can be loaded with data and programmed into one page. If data needs to be written to different pages, the loading and writing needs to be repeated.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>byte_addr</em>&nbsp;</td><td>EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Byte value to write to buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02f10adbf959b8525bbaf777ad6e43b6"></a><!-- doxytag: member="nvm.c::nvm_eeprom_load_page_to_buffer" ref="ga02f10adbf959b8525bbaf777ad6e43b6" args="(const uint8_t *values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_load_page_to_buffer </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>values</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load entire page into temporary EEPROM page buffer. </p>
<p>This function loads an entire EEPROM page from an SRAM buffer to the EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only the lower part of the address is used to address the buffer. Therefore, no address parameter is needed. In the end, the data is written to the EEPROM page given by the address parameter to the EEPROM write page operation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>Pointer to SRAM buffer containing an entire page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bb4f6cdba9a963add9bf84ee085eb0d"></a><!-- doxytag: member="nvm.c::nvm_eeprom_read_byte" ref="ga7bb4f6cdba9a963add9bf84ee085eb0d" args="(uint8_t page_addr, uint8_t byte_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t nvm_eeprom_read_byte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byte_addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read one byte from EEPROM using IO mapping. </p>
<p>This function reads one byte from EEPROM using IO-mapped access. If memory mapped EEPROM is enabled, this function will not work.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_addr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byte_addr</em>&nbsp;</td><td>EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Byte value read from EEPROM. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8b5ca90e2d370109bed6e6adc8d9307"></a><!-- doxytag: member="nvm.c::nvm_eeprom_split_write_page" ref="gae8b5ca90e2d370109bed6e6adc8d9307" args="(uint8_t page_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_split_write_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>page_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write (without erasing) EEPROM page. </p>
<p>This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.</p>
<p>As this is a split write, the page in EEPROM will _not_ be erased before writing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_addr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc559e7bbb0598a1e4c8b3f4344bdc51"></a><!-- doxytag: member="nvm.c::nvm_eeprom_write_byte" ref="gafc559e7bbb0598a1e4c8b3f4344bdc51" args="(uint8_t page_addr, uint8_t byte_addr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_write_byte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byte_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write one byte to EEPROM using IO mapping. </p>
<p>This function writes one byte to EEPROM using IO-mapped access. If memory mapped EEPROM is enabled, this function will not work. This functiom will cancel all ongoing EEPROM page buffer loading operations, if any.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_addr</em>&nbsp;</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byte_addr</em>&nbsp;</td><td>EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Byte value to write to EEPROM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="6" height="1" background="blue.gif"></td>
  </tr>

  <tr>
    <td colspan="6">
    <address style="align: right;"><small>
Generated on Fri Oct 22 12:15:26 2010 for AVR1300 Using the Xmega ADC by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.6.3</small></address>
    </td>
  </tr>

</table>
